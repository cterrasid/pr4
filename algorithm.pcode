const
    MAX_STUDENTS: integer = 20;      { Max. number of students }
    NUM_ACTIVITIES: integer = 7;     { Max. number of activities of the subject }
    NUM_CAA_ACTIVITIES: integer = 4; { Number of CAA activities }
    NUM_PR_ACTIVITIES: integer = 3;  { Number of PR activities }

    MIN_C_MINUS: real = 3.0;         { Minimum mark for grade C- }
    MIN_C_PLUS: real = 5.0;          { Minimum mark for grade C+ }
    MIN_B: real = 7.0;               { Minimum mark for grade B }
    MIN_A: real = 9.0;               { Minimum mark for grade A }

    CAA1_WEIGHT: integer = 10;       { Percent weight of CAA1 in CAA grade }
    CAA2_WEIGHT: integer = 20;       { Percent weight of CAA2 in CAA grade }
    CAA3_WEIGHT: integer = 30;       { Percent weight of CAA3 in CAA grade }
    CAA4_WEIGHT: integer = 40;       { Percent weight of CAA4 in CAA grade }
    PR1_WEIGHT: integer = 20;        { Percent weight of PR1 in PR grade }
    PR2_WEIGHT: integer = 30;        { Percent weight of PR2 in PR grade }
    PR3_WEIGHT: integer = 50;        { Percent weight of PR3 in PR grade }

    { TODO: Agregar constantes necesarias...}
    TOTAL_WEIGHT: integer = 100;     { Total weight for CAA or PR activities group }
    FINAL_CAA_WEIGHT: integer = 30;    { Final CAA weight }
    FINAL_PR_WEIGHT: integer = 70;     { Final PR weight }
end const

type
    { User defined types }
    tGrade = {A, B, C_PLUS, C_MINUS, D}
    tActivityType = {CAA, PR}
    tActivityName = {CAA1, CAA2, CAA3, CAA4, PR1, PR2, PR3}
    tActivityState = {SUBMITTED, NOT_SUBMITTED, EXCLUDED}

    tActivity = record
        name: tActivityName;    { Activity Name }
        state: tActivityState;  { Activity State }
        mark: real;             { Activity Mark }
    end record

    tStudent = record
        studentId: integer; { Student ID }
        name: string; { Student Name }
        activities: vector[NUM_ACTIVITIES] of tActivity; { Student Activities }
        {Exercise 1}
        caaMark: real;  { Student final CAA mark }
        prMark: real;   { Student final PR mark }
        nCaa: integer;  { Student number of submitted CAA activities }
        nPr: integer;   { Student number of submitted PR activities }
        finalMark: real; { Student final mark }
        absent: boolean; { Student is absent }
    end record
    
    tStudentsTable = record
        students: vector[MAX_STUDENTS] of tStudent; { Students info and grades }
        nStudents: integer; { Number of students }
    end record

end type
    
{Exercise 1: 2. Read data from marks file}
action studentsLoadDataFromFile (
    in filename: string,
    out studentsTable: tStudentsTable,
    out isRead: boolean
  )
    var
      fileToRead: file;
      newStudent: tStudent;
      i: integer;
    end var;
  
    fileToRead := openFile(filename);
    if fileToRead ≠ NULL then
  
      { Initialize table }
      studentsTable.nStudents := 0;
  
      while not isEndOfFile(fileToRead) and studentsTable.nStudents < MAX_STUDENTS do
        newStudent.studentId := readIntegerFromFile(fileToRead);
        newStudent.name := readStringFromFile(fileToRead);
        for i := 1 to NUM_ACTIVITIES do
          { Read mark and activity state }
          newStudent.activities[i].mark := readRealFromFile(fileToRead);
          newStudent.activities[i].state := readEnumFromFile(fileToRead);
          { Assign activity name }
           if i := 1 then
               newStudent.activities[i].name := CAA1;
           else
               if i := 2 then
                   newStudent.activities[i].name := CAA2;
               else
                   if i := 3 then
                       newStudent.activities[i].name := CAA3;
                   else
                       if i := 4 then
                           newStudent.activities[i].name := CAA4;
                       else
                           if i := 5 then
                               newStudent.activities[i].name := PR1;
                           else
                               if i := 6 then
                                   newStudent.activities[i].name := PR2;
                               else
                                   newStudent.activities[i].name := PR3;
                               end if
                           end if
                       end if
                   end if
               end if
           end if
            
        end for;
  
        { Add newStudent to studentsTable }
         studentsTable.nStudents := studentsTable.nStudents + 1;
         studentsTable.students[studentsTable.nStudents] := newStudent;
      end while;
      closeFile(fileToRead);
      isRead := true;
    else
      isRead := false;
    end if;
end action;

{ Assign activity weight according to activity name and type}
action activityTypeWeight (
    in activity: tActivityName,
    out activityType: tActivityType,
    out activityWeight: real
  )
    activityType := CAA;
    if activity = CAA1 then
        activityWeight := integerToReal(CAA1_WEIGHT);
    else
        if activity = CAA2 then
            activityWeight := integerToReal(CAA2_WEIGHT);
        else
            if activity = CAA3 then
                activityWeight := integerToReal(CAA3_WEIGHT);
            else
                if activity = CAA4 then
                    activityWeight := integerToReal(CAA4_WEIGHT);
                else
                    activityType := PR;
                    if activity = PR1 then
                        activityWeight := integerToReal(PR1_WEIGHT);
                    else
                        if activity = PR2 then
                            activityWeight := integerToReal(PR2_WEIGHT);
                        else
                            activityWeight := integerToReal(PR3_WEIGHT);
                        end if
                    end if
                end if
            end if
        end if
    end if
end action

{ Check for all submitter PR activities }
function allSubmittedPr (nSubmittedPr: integer): boolean
    return nSubmittedPr = NUM_PR_ACTIVITIES;
end function

{ Exercise 2 }
{ Calculate the CAA and PR final mark (separated) for each student, with 2 decimals precision }
{ Count the number of submitted CAA and PR activities using finalMarkByActivity and activityTypeNumber }
action calculateFinalMarkByActivityType (inout student: tStudent)
    var
        activityType: tActivityType;
        activityWeight: real;
        mark: real;
        i: integer;
    end var
    
    { Initializations }
    student.caaMark := 0.0;
    student.prMark := 0.0;
    student.nCaa := 0;
    student.nPr := 0;
    
    for i := 1 to NUM_ACTIVITIES do
        activityTypeWeight(student.activities[i].name, activityType, activityWeight);
        mark := student.activities[i].mark * activityWeight;
        
        if activityType = CAA then
            student.caaMark := student.caaMark + mark;
            if student.activities[i].state = SUBMITTED then
                student.nCaa := student.nCaa + 1;
            end if
        else
            student.prMark := student.prMark + mark;
            if student.activities[i].state = SUBMITTED then
                student.nPr := student.nPr + 1;
            end if
        end if

    end for
    student.caaMark := student.caaMark / TOTAL_WEIGHT;
    student.prMark := student.prMark / TOTAL_WEIGHT;
end action

{ Exercise 3 }
{Calculate final mark for each student}
action calculateFinalMark (inout student: tStudent)
    {Si la nota final de CAA no llega a 4, la nota final de EC será la de CAA}
    if student.caaMark < 4 then
        student.finalMark := student.caaMark;
    else
    {Si la nota final de PR no llega a 5, la nota final de EC será la de PR}
        if student.prMark < 5 then
            student.finalMark := student.prMark;
        else
        {En cualquier otro caso, la nota final de EC será la media ponderada de la nota final de CAA (30%) y la nota final de PR (70%)}
            student.finalMark := (student.caaMark * FINAL_CAA_WEIGHT + student.prMark * FINAL_PR_WEIGHT) / TOTAL_WEIGHT;
            {Si la nota final de EC está aprobada, pero no se han entregado todas las PR, la nota final de EC será un 4. Utilizar la función allSubmittedPr}
            student.absent := not allSubmittedPr(student.nPr);
            if student.absent then
                student.finalMark := 4;
            end if
        end if
    end if
end action

{ Exercise 4 }
{ Save data to file }
action saveAndDisplayStudentsData (in studentsTable: tStudentsTable)
    var
        i: integer;
        fileToWrite: file;
    end var
    
    { Initialize variables }
    fileToWrite := openFile("grades.txt");
    
    if studentsTable.nStudents = 0 then
        writeString(“STUDENT LIST EMPTY”);
    else
        {ID estudiante}
        writeIntegerToFile(fileToWrite, studentsTable.students[i].studentId);
        {nombre estudiante}
        writeStringToFile(fileToWrite, studentsTable.students[i].name);
        {nota final CAA y PR estudiante}
        writeRealToFile(fileToWrite, studentsTable.students[i].caaMark);
        writeRealToFile(fileToWrite, studentsTable.students[i].prMark);
        {numero de actividades CAA y PR estudiante}
        writeIntegerToFile(fileToWrite, studentsTable.students[i].nCaa);
        writeIntegerToFile(fileToWrite, studentsTable.students[i].nPr);
        {nota final de EC estudiante}
        writeRealToFile(fileToWrite, studentsTable.students[i].finalMark);
        {registro de No Presentado estudiante}
        writeBooleanToFile(fileToWrite, studentsTable.students[i].absent);
    end if
    
    writeStudentsData(studentsTable);
    closeFile(fileToWrite);
end action

{ Exercise 5 }
action sortDescendingByFinalMark (inout studentsTable: tStudentsTable)
    {Ordenar tabla de estudiantes por nota final de EC de forma descendente}
    var
        {Defino variables para iterar normaL (i)}
        {para designar segunda posición (j)}
        {para guardar la posición del mínimo (posMin)}
        i, j, posMin: integer;
        {para intercambiar valores (aux)}
        aux: tStudent;
    end var
    
    { Initialize variables }
    i := 1;
    {Itero sobre la tabla de estudiantes con i}
    while i < studentsTable.nStudents do
        {La posición mínima es la actual, o sea i}
        posMin := i;
        {j es la posición siguiente a i}
        j := i + 1;
        {Itero sobre la tabla de estudiantes con j, desde i+1 hasta el final}
        while j <= studentsTable.nStudents do
            {Si la nota final de EC de la posición j es mayor que la de la posición posMin, actualizo posMin}
            if studentsTable.students[j].finalMark > studentsTable.students[posMin].finalMark then
                posMin := j;
            else
                {Si hay empate en la nota final de EC, irá primero el estudiante con menor ID}
                if studentsTable.students[j].finalMark = studentsTable.students[posMin].finalMark then
                    if studentsTable.students[j].studentId < studentsTable.students[posMin].studentId then
                        posMin := j;
                    end if
                end if
            end if
            j := j + 1;
        end while
        {Si la posición mínima no es la actual, intercambio los valores}
        if posMin ≠ i then
            aux := studentsTable.students[posMin];
            studentsTable.students[posMin] := studentsTable.students[i];
            studentsTable.students[i] := aux;
        end if
        i := i + 1;
    end while
    {Mostrar por pantalla la lista de estudiantes ordenada}
    writeStudentsData(studentsTable);
end action

{ Display student data }
action writeStudentsData (in studentsTable: tStudentsTable)
    var
        i: integer;
    end var
    
    if studentsTable.nStudents = 0 then
        writeString(“STUDENT LIST EMPTY”);
    else
        writeString(ID NAME CAA_MARK PR_MARK N_CAA N_PR FINAL_MARK ABSENT?(1=YES)”);
        writeString(“--------------------------------------------------------------------------------------------------------------------”);

        for i := 1 to studentsTable.nStudents do
            writeInteger(studentsTable.students[i].studentId);
            writeString(studentsTable.students[i].name);
            writeReal(studentsTable.students[i].caaMark);
            writeReal(studentsTable.students[i].prMark);
            writeInteger(studentsTable.students[i].nCaa);
            writeInteger(studentsTable.students[i].nPr);
            writeReal(studentsTable.students[i].finalMark);
            writeBoolean(studentsTable.students[i].absent);
        end for
    end if
end action

algorithm UOCSubjectGrades
    var
        studentsTable: tStudentsTable;
        i, studentId: integer;
        filename: string;
        isRead, found: boolean;
        approvedPercent: real;
        {...}
    end var

    {Initialize variables}

    { Exercise 1 }
    { Load data from file }
    writeString("LOAD DATA FROM FILE. ENTER FILENAME >>");
    filename := readString();
    studentsLoadDataFromFile(filename, studentsTable, isRead);

    if isRead then
        writeString("RESULTS:");
        for i := 1 to studentsTable.nStudents do
            { Exercise 2 }
            calculateFinalMarkByActivityType(studentsTable.students[i]);
            { Exercise 3 }
            calculateFinalMark(studentsTable.students[i]);
        end for
        { Exercise 4 }
        saveAndDisplayStudentsData(studentsTable);
        writeString("STUDENTS MARKS");
        writeString("==============");
        { Exercise 5 }
        sortDescendingByFinalMark(studentsTable);
    else
        writeString("NO STUDENTS RECOVERED");
    end if
end algorithm